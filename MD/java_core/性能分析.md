在系统层面能够影响应用性能的一般包括3个因素：CPU、内存和IO

```sh
free -m # 按兆字节显示
sar -n DEV l #查看网络设备吞吐率

top -p [processId] -H
ps -Le
```

#### 1、CPU分析
cpu使用率：top、vmstat、ps

一般说来，CPU繁忙的原因有以下几下：
- 线程中有无限空循环、无阻塞、正则匹配或者单纯的计算
- 发生了频繁的GC
- 多线程的上下文切换

jstack 打印进程堆栈信息
```
jstat -gcutil [pid] #查看对应进程GC信息，判断是否是GC造成CPU繁忙
```

#### 2、内存分析
堆内存 jmap
```sh
jmap -heap <pid> #查看JVM内存使用状况

jmap -histo:live <pid> #查看JVM内存存活的对象

# dump 出heap里所有对象
jmap -dump:format=b, file=xxx.hprof <pid>
# 先做一次 Full GC，再dump依然存活的对象信息
jmap -dump:format=b, live, file=xxx.hprof <pid>
```

#### 3、I/O分析
与应用性能相关的I/O分析包括文件IO和网络IO

##### 文件I/O
```sh
pidstat、iostat、vmstat #查看IO状况
```

造成文件I/O性能差的原因
- 大量随机读/写
- 设备慢
- 文件太大

##### 网络I/O
```sh
netstat -anp #查看所有连接的状况、数目、端口信息等

# 监听 80端口的网络请求并打印日志到 tmp.cap 中
tcodump -i eth0 -w tmp.cap -tnn dst port 80
```

---
#### 服务CPU100%问题快速定位
> https://mp.weixin.qq.com/s/Xb1im4jG_Cobhas4q4YT1Q

##### 1、找到最耗CPU的进程
工具 top
```sh
1. top -c #显示进行运行信息
2. 键入大P，进程按照CPU使用率排序
3. 找出最耗资源进程PID # 10765
```

##### 2、找到最耗CPU的线程
```sh
1. top -Hp 10765 #显示一个进程的线程运行信息列表
2. 键入P，线程按照CPU使用率排序
3. 将线程PID转化为16进制 #因为堆栈里，线程id是用16进制表示
  printf “%x\n” 10804
  # 10804对应的16进制是0x2a34
```

##### 3、打印进程堆栈
```
1. jstack 10765 | grep '0x2a34' -C5 --color

2. 找到耗CPU高的线程对应的线程名称"AsyncLogger-1"，以及该线程正在执行代码的堆栈
```

#### 线上操作与线上问题排查
> https://mp.weixin.qq.com/s/ZZp0H5vIBNu47KsiJOju2Q

#### 线上服务内存OOM问题定位三板斧
> https://mp.weixin.qq.com/s/iOC1fiKDItn3QY5abWIelg

Java服务OOM，最常见的原因为：

- 有可能是内存分配确实过小，而正常业务使用了大量内存
- 某一个对象被频繁申请，却没有释放，内存不断泄漏，导致内存耗尽
- 某一个资源被频繁申请，系统资源耗尽，例如：不断创建线程，不断发起网络连接

##### 1、找出消耗的服务进程ID
##### 2、是否内存本身分配过小
```
1. 查看新生代，老年代堆内存的分配大小以及使用情况
jmap -heap 10765

2. 找到最耗内存的对象
jmap -histo:live 10765 | more
显示存活对象的信息，并按照所占内存大小排序：
- 实例数、所占内存大小、类名
```

如果发现某类对象占用内存很大（例如几个G），很可能是类对象创建太多，且一直未释放。例如：
- 申请完资源后，未调用close()或dispose()释放资源
- 消费者消费速度慢（或停止消费了），而生产者不断往队列中投递任务，导致队列中任务累积过多

##### 3、是否是资源耗尽
查看进程创建的线程数，以及网络连接数，如果资源耗尽，也可能出现OOM

工具：pstree、netstat

资源监控
- 数据库：负载，慢SQL，连接数
- 缓存：连接数，占用内存，吞吐量，响应时间
- 消息队列：响应时间，吞吐量，负载，积压情况