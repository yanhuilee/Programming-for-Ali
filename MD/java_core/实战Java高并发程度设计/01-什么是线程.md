#### 什么是线程？
> 操作系统能够进行运算调度的最小单位。一个标准的线程由线程ID，当前指令指针（pc），寄存器集合和堆栈组成。线程共享进程的资源

##### 线程优先级
> **线程调度**，线程分配到的时间片多少决定了线程使用处理器资源的多少，而线程优先级就是决定线程需要多或者少分配一些处理器资源的线程属性

#### 1、先要了解的概念
- 同步(Synchronous)、异步(Asyn)
- 并发(Concurrency)、并发(Parallelism)
- 临界区
- 阻塞、非阻塞(Non-Blocking)
- 死锁(Deadlock)、饥饿(Starvation)、活锁(Livelock)


#### 2、线程六种状态

```java
public enum State {
  NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED;
}
```


### 线程安全
线程安全三个特性：原子性，可见性，有序性

#### synchronized

synchronized：独占（排他），可见，重入
- 普通方法，锁的是当前对象
- 静态方法，锁的是当前 Class 对象
- 块，锁的是 (this-实例对象，class-类对象，obj-实例对象) 中的对象

如果锁的是类对象，尽管new多个实例对象，但他们仍然是属于同一个类会被锁住

当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁

#### Monitor 监视器对象（互斥锁）
- 使用：this / static
- monitor 机制：字节码中会添加 monitorenter 和 monitorexit
- 锁的重入性: 每个对象拥有一个计数器，当线程获取该对象锁后，计数器就会加一，释放锁后就会将计数器减一
- 原子性：i++
- synchronized 的 happens-before 关系
- synchronized 内存语义：共享变量刷新到主内存，每次读取最新值

#### volatile实现原理
> 在生成汇编代码时会在volatile修饰的共享变量进行写操作的时候会多出 Lock前缀 的指令

1. Lock前缀的指令会引起处理器缓存写回内存；
2. 一个处理器的缓存回写到内存会导致其他处理器的缓存（cache line）失效； 当处理器发现本地缓存失效后，就会从内存中重读该变量数据

```
volatile boolean flag = false
```

##### intel的手册对lock前缀的说明如下
1. 确保对内存的读-改-写操作原子执行。

锁住总线，使得其他处理器暂时无法通过总线访问内存。
缓存锁定（Cache Locking）

2. 禁止该指令，与之前和之后的读和写指令重排序。
3. 把写缓冲区中的所有数据刷新到内存中。

上面的第2点和第3点所具有的内存屏障效果，足以同时实现volatile读和写的内存语义。 经过上面的分析，现在我们终于能明白为什么JDK文档说CAS同时具有volatile读和 volatile写的内存语义了。

#### volatile 和 synchronized区别
volatile | synchronized
---|---
告诉jvm当前变量在寄存器中的值是不确定的,需要从主存中读取 | 锁定当前变量,只有当前线程可以访问该变量
变量级别 | 变量,方法
可见性，有序性 | 可见性和原子性有序性（重量级）
不阻塞 | 阻塞