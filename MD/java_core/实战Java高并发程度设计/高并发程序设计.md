#### 多线程
耗时的I/O操作：
- 一般来说，文件与网络的I/O处理都非常消耗时间，如果在I/O处理期间，程序基本上无法执行其他处理，性能将会下降。在这种情况下，就可以使用多线程来解决。
- 如果执行I/O处理的线程和执行其他处理的线程分开，那么在I/O处理期间，其他处理也可以同时进行。
- nio包：即使不用线程，也可以执行兼具性能和可扩展性的I/O处理

```java
package java.util.concurrent;

public interface ThreadFactory {
    Thread newThread(Runnable r);
}

ThreadFactory factory = Executors.defaultThreadFactory()
factory.newThread(new xx).start()
```

#### Single Threaded Execution


#### 3、JDK 并发包
- 多线程协作：同步控制
synchronized 的功能扩展：重入锁 和 Condition 条件
- 线程复用：线程池
- 并发容器


#### Future

重入锁：显式加锁，中断响应，限时等待，公平锁（饥饿，有序队列）
		原子状态：CAS操作
		等待队列
		阻塞原语：park()/unpark() 挂起/恢复线程 -- LockSupport
Condition: 重入锁好搭档
	await()
	signal()
Semaphore
线程池：内部实现，拒绝策略，Fork/Join  P105
	线程用完归还（不关闭）
	jdk对线程池的支持：Executor 框架：
		ThreadPoolExecutor
		四种类型：fixed, single, cached, scheduled
并发容器：
	高效读写队列：ConcurrentLinkedQueue
	高效读取，不变模式下的CopyOnWriteArrayList
	数据共享通道：BlockingQueue
	随机数据结构：SkipList
ThreadLocal：
无锁：
	CAS
	AtomicInteger
	java 中的指针：Unsafe 类
生产者消费者模式
准备好了再通知我：NIO
读完了再通知我：AIO