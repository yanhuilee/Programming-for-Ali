### 大纲
- 1、synchronized 和 ReentrantLock有什么区别呢？
- 2、synchronized底层如何实现？什么是锁的升级、降级？
- 3、一个线程两次调用start()方法会出现什么情况？
- 4、什么情况下Java程序会产生死锁？如何定位、修复？
- 5、Java并发包提供了哪些并发工具类？
- 6、并发包中的ConcurrentLinkedQueue 和 LinkedBlockingQueue有什么区别？
- 7、[Java并发类库提供的线程池有哪几种？分别有什么特点？](https://github.com/yanhuilee/Programming-for-Ali/blob/master/MD/java_core/实战Java高并发程度设计/02-线程池.md)
- 8、AtomicInteger底层实现原理是什么？如何在自己的产品代码中应用CAS操作？


### 1、synchronized 和 ReentrantLock 区别？

- synchronized 是 Java 内建的同步机制，它提供了互斥的语义和可见性，当一个线程已经获取当前锁时，其他试图获取的线程只能等待或者阻塞

- ReentrantLock，重入锁，通过lock() 获取，可以控制公平性

锁作为并发基础工具之一，至少需要掌握：什么是线程安全？基本使用与案例，更进一步：
- 掌握 synchronized、ReentrantLock 底层实现；理解锁膨胀、降级；理解偏斜锁、自旋锁、轻量级锁、重量级锁等概念
- 掌握并发包中 `java.util.concurrent.lock` 各种不同实现和案例分析

线程安全是一个多线程环境下正确性的概念，也就是保证多线程环境下 **共享的、可修改的**状态的正确性

换个角度来看，如果状态不是共享的，或者不是可修改的，也就不存在线程安全问题，进而可以推理出保证线程安全的两个办法：

- 封装：通过封装，可以将对象内部状态隐藏、保护起来
- 不可变：final 和 immutable，就是这个道理，Java 语言目前还没有真正意义上的原生不可变

线程安全需要保证几个基本特性：

-  **原子性**，简单说就是相关操作不会中途被其他线程干扰，一般通过同步机制实现
-  **可见性**，是一个线程修改了某个共享变量，其状态能够立即被其他线程知晓，通常被解释为将线程本地状态反映到主内存上，volatile 就是负责保证可见性的
-  **有序性**，是保证线程内串行语义，避免指令重排等

#### ReentrantLock
> 公平性是指在竞争场景中，会倾向于将锁赋予等待时间最久的线程。公平性是减少线程“饥饿”（个别线程长期等待锁，但始终无法获取）情况发生的一个办法

```java
// 为保证锁释放，每一个 lock() 动作，建议都立即对应一个 try-catch-finally
ReentrantLock fairLock = new ReentrantLock(true);
fairLock.lock();
try {
	// do something
} finally {
 	fairLock.unlock();
}
```

- ArrayBlockingQueue、Condition

```java
public E take() throws InterruptedException {
	final ReentrantLock lock = this.lock;
	lock.lockInterruptibly();
	try {
	    // 当队列为空时，试图 take 的线程等待入队发生，而不是直接返回
    	while (count == 0)
        	notEmpty.await();
    	return dequeue();
	} finally {
    	lock.unlock();
	}
}
```


### 2、synchronized 底层如何实现？什么是锁的升级、降级？

synchronized 代码块是由一对 monitorenter/monitorexit 指令实现，Monitor对象是同步的基本实现单元

JVM 提供了三种不同的 Monitor 实现，也就是常说的三种不同的锁：偏斜锁（Biased Locking）、轻量级锁和重量级锁，大大改进了其性能。当 JVM检测到不同的竞争状况时，会自动切换到适合的锁实现。

当没有竞争出现时，默认会使用偏斜锁。JVM 会利用 CAS 操作（compare and swap），在对象头上的 Mark Word 部分设置线程ID，以表示这个对象偏向于当前线程，并不涉及真正的互斥锁。这样做的假设是基于在很多应用场景中，大部分对象生命周期中最多会被一个线程锁定，使用偏斜锁可以降低无竞争开销。

如果有另外的线程试图锁定某个已经被偏斜过的对象，JVM 就需要撤销（revoke）偏斜锁，并切换到轻量级锁实现。轻量级锁依赖 CAS 操作 Mark Word 来试图获取锁，如果重试成功，就使用普通的轻量级锁；否则，进一步升级为重量级锁。

上一讲提到过 synchronized 是 JVM 内部的 Intrinsic Lock，所以偏斜锁、轻量级锁、重量级锁的代码实现，并不在核心类库部分，而是在 JVM 的代码中。


### 3、一个线程两次调用start()方法会出现什么情况？

线程是不允许启动两次的，必然会抛出IllegalThreadStateException，运行时异常，是编程错误。

#### 谈谈线程的生命周期和状态转移
`java.lang.Thread.State`

- 新建（NEW），线程被创建出来还没真正启动
- 就绪（RUNNABLE），线程已经在 JVM 中执行，但由于执行需要计算资源，它可能是正在运行，或在就绪队列里面排队，等待系统分配给它 CPU 片段

- 阻塞（BLOCKED），阻塞表示线程在等待 Monitor lock。比如，线程试图通过 synchronized 去获取某个锁，但是其他线程已经独占了，那么当前线程就会处于阻塞状态

- 等待（WAITING），表示正在等待其他线程采取某些操作。一个常见的场景是类似生产者消费者模式，发现任务条件尚未满足，就让当前消费者线程等待（`wait`），另外的生产者线程去准备任务数据，然后通过类似 notify 等动作，通知消费线程可以继续工作了。`Thread.join()` 也会令线程进入等待状态。

- 计时等待（TIMED_WAIT），其进入条件和等待状态类似，但是调用的是存在超时条件的方法，比如 wait 或 join 等方法的指定超时版本，如下面示例：
```
public final native void wait(long timeout) throws InterruptedException;
```

线程是系统调度的最小单元，一个进程可以包含多个线程，作为任务的真正运作者，有自己的栈（Stack）、寄存器（Register）、本地存储（Thread Local）等，但是会和进程内其他线程共享文件描述符、虚拟地址空间等。

```java
Runnable task = () -> {System.out.println("Hello World!");};
Thread myThread = new Thread(task);
myThread.start();
```

```java
Future future = Executors.newFixedThreadPool(1)
    .submit(task)
    .get()
```

利用 Future 等机制更好地处理执行结果。线程生命周期通常和业务之间没有本质联系，混淆实现需求和业务需求，就会降低开发的效率。

从线程生命周期的状态开始展开，那么在 Java 编程中，有哪些因素可能影响线程的状态呢？主要有：

- 线程自身的方法，除了 start，还有多个 join()，等待线程结束；yield 是告诉调度器，主动让出 CPU

- 基类 Object 提供了一些基础的 wait/notify/notifyAll()。如果我们持有某个对象的 Monitor 锁，调用 wait 会让当前线程处于等待状态，直到其他线程 notify/notifyAll。所以，本质上是提供了 Monitor 的获取和释放的能力，是基本的线程间通信方式。

- 并发类库中的工具，比如 `CountDownLatch.await()` 会让当前线程进入等待状态，直到 latch 被计数为 0，这可以看作是线程间通信的 Signal。

#### 使用建议
在多核 CPU 的系统中，线程等待存在一种可能，就是在没有任何线程广播或者发出信号的情况下，线程就被唤醒，如果处理不当就可能出现诡异的并发问题，所以我们在等待条件过程中，建议采用下面模式来书写：
```java
// 推荐
while ( isCondition()) {
    waitForAConfition(...);
}

// 不推荐，可能引入 bug
if ( isCondition()) {}
```

再有就是慎用 `ThreadLocal`，这是 Java 提供的一种保存线程私有信息的机制，因为其在整个线程生命周期内有效，所以可以方便地在一个线程关联的不同业务模块之间传递信息，比如事务 ID、Cookie 等上下文相关信息。它的实现结构，数据存储于线程相关的 ThreadLocalMap，其内部条目是弱引用，如下面片段:

```java
static class ThreadLocalMap {
	static class Entry extends WeakReference<ThreadLocal<?>> {
    	/** The value associated with this ThreadLocal. */
    	Object value;
    	Entry(ThreadLocal<?> k, Object v) {
        	super(k);
    	    value = v;
    	}
    }
}
```


### 4、什么情况下Java程序会产生死锁？如何定位、修复？

> 两个或多个线程之间，由于互相持有对方需要的锁，而永久处于阻塞的状态。

定位死锁最常见的方式就是利用 `jstack`等工具获取线程栈，然后定位互相之间的依赖关系，进而找到死锁。如果是比较明显的死锁，往往 jstack 等就能直接定位，类似 JConsole 甚至可以在图形界面进行有限的死锁检测。

如果程序运行时发生了死锁，绝大多数情况下都是无法在线解决的，只能重启、修正程序本身问题。所以，代码开发阶段互相审查，或者利用工具进行预防性排查，往往也是很重要的。

今天的问题偏向于实用场景，大部分死锁本身并不难定位，掌握基本思路和工具使用，理解线程相关的基本概念，比如各种线程状态和同步、锁、Latch 等并发工具，就已经足够解决大多数问题了。

针对死锁，可以深入考察：
- 写一个可能死锁的程序，考察下基本的线程编程
- 诊断死锁有哪些工具，如果是分布式环境，可能更关心能否用 API 实现吗
- 后期诊断死锁还是挺痛苦的，如何在编程中尽量避免一些典型场景的死锁，有其他工具辅助吗

##### 排查
- 首先，可以使用 jps 或者系统的 ps 命令、任务管理器等工具，确定进程 ID
- 其次，调用 jstack 获取线程栈：`jstack your_pid`
- 找到处于 BLOCKED 状态的线程，按照试图获取（waiting）的锁 ID 查找，很快就定位问题

如果开发自己的管理工具，需要用更加程序化的方式扫描服务进程、定位死锁，可以考虑使用 Java 提供的标准管理 API，`ThreadMXBean`，其直接就提供了 `findDeadlockedThreads()` 用于定位。

```java
public static void main(String[] args) throws InterruptedException {
	ThreadMXBean mbean = ManagementFactory.getThreadMXBean();
	
	Runnable dlCheck = new Runnable() {
    	@Override
    	public void run() {
        	long[] threadIds = mbean.findDeadlockedThreads();
        	if (threadIds != null) {
                    ThreadInfo[] threadInfos = mbean.getThreadInfo(threadIds);
                    System.out.println("Detected deadlock threads:");
            	for (ThreadInfo threadInfo : threadInfos) {
                	System.out.println(threadInfo.getThreadName());
            	}
            }
        }
    };

    ScheduledExecutorService scheduler =Executors.newScheduledThreadPool(1);
    // 稍等 5 秒，然后每 10 秒进行一次死锁扫描
    scheduler.scheduleAtFixedRate(dlCheck, 5L, 10L, TimeUnit.SECONDS);
    // 死锁样例代码 …
}
```

重新编译执行，你就能看到死锁被定位到的输出。在实际应用中，就可以据此收集进一步的信息，然后进行预警等后续处理。但是要注意的是，对线程进行快照本身是一个相对重量级的操作，还是要慎重选择频度和时机。

#### 如何在编程中尽量预防死锁呢？

死锁的发生：
- 互斥条件，类似 Java 中 Monitor 都是独占的
- 互斥条件是长期持有的，在使用结束之前，自己不会释放，也不能被其他线程抢占
- 循环依赖关系，两个或者多个个体之间出现了锁的链条环

所以，我们可以据此分析可能的避免死锁的思路和方法。

- 方法一: 尽可能避免使用多个锁，只有需要时才持有锁
```java
// Thread HttpClient-6-SelectorManager:
readLock.lock();
writeLock.lock();
// 持有 readLock/writeLock，调用 close() 需要获得 closeLock
close()
// Thread HttpClient-6-Worker-2 持有 closeLock
implCloseSelectableChannel (); // 想获得 readLock
```

- 方法二：银行家算法
- 方法三：使用带超时的方法 `timed_wait()`
