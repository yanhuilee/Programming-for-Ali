### 大纲
- 1、存储引擎
- 2、索引的使用
- 3、查询缓存
- 4、数据同步中的 Binlog
- 5、事务机制
- 6、锁机制
- 7、大表优化
- 8、高可用支持
- 10、连接池 druid


### 关系型数据库－MySQL
#### 1、存储引擎
MyISAM:
- 不支持行锁，读取时对需要读到的所有表加锁，写入时加排他锁
- 全文索引，支持BLOB和TEXT的前500个字符索引
- 延迟更新索引，提升写入性能
- 适合读密集型表

InnoDB：
- 行锁，采用MVCC来支持高并发，有可能死锁
- 聚集索引
- 索引文件和数据文件是分离的，叶子节点data域保存了完整的数据记录

由于 MyISAM 缓存有表 meta-data （行数等） ，因此在做 COUNT（叮时对于一个结构很好的查询是不需要消耗多少资源的。 而对于 InnoDB 来说，则没有这种缓存。 当你需要行 锁定、事务时，使用 InnoDB 则是更好的选择， 也具有更高级的安全性


#### 2、索引的使用
MySQL 的 BTree 索引使用的是 B 树中的 B+Tree，但对于主要的两种存储引擎其实现方式是不同的。

- MylSAM: B+Tree 叶节点的 data 域存放的是数据记录的地址。 在索引检索时，首先按照 B+Tree 搜索算法搜索索引，如果指定的 Key 存在，则取出其 data 域的值，然 后以 data域的值为地址读取相应的数据记录。 这被称为非聚簇索引。

- lnnoDB：其数据文件本身就是索引文件。相比MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录。 这个索引的 key 是数据表的主键，因此 InnoDB 表数据文件本身就是主索引。 这被称为聚集索引。

其余的索引都为辅助索引，辅助索引 data域存储相应记录主键的值而不是地址，这也是和 MyISAM 不同的地方。 在根据主索引搜索时，直接找到 key 所在的节点即可取出数据；在根据辅助索引查找时，则需要先取汁l主键的值，再走一遍主索引。因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成**主索引频繁分裂**。


explain 获取执行计划，会随数据分布情况而变动
```
type: ALL-全表扫描
key：索引键
extra: using Index -索引覆盖
	Using filesort（需要额外的步骤来发现如何对返回的行排序）
	Using temporary（需要创建一个临时表来存储结果），说明查询需要优化。
```

MySQL是有查询优化器的，优化器的作用就是在一个查询所有可能的执行方式中找到其中最好的执行计划。 因此 explain 获取到的执行计划并非是固定的，它会随着数据分布情况而变动。 而且当数据库计算出使用索引所耗费的时间长于全表扫描或其他操作时（比如当表中索引字段数据重复率太高），将不会使用索引。

- 1）最左前缀原则。如果查询的时候查询 条件精确匹配索引的左边连续一列或几列，则此列就可以被用到。 

由于最左前缀原则 ，在创建联合索引时，索引字段的顺序需要考虑宇段值去重之后的个数，较多的放前面。 ORDER BY 子句也遵循此规则

- 2）避免 where 子句中对宇段施加函数，，如 `to_date(create_time) ＞ xx`这会造成无法命中索引
- 3）在使用 InnoDB时使用与业务无关的自增主键作为主键，即使用逻辑主键
- 4）合理利用索引覆盖。

覆盖索引(
covering index)指一个查询语句的执行只需要从辅助索引中就可以得到查询记录，而不需要查询聚集索引中的记录，也可以称之为实现了索引覆盖。简单来说就是查询条件命中了索引，而查询宇段也属于索引中的字段，那么就实现了索引覆盖。 当实现覆盖索引的时候， explain 命令的 Extra 会显示 using Index。

- 5）避免冗余索引
- 6）将打算加索引的列设置为 NOT NULL，否则将导致引擎放弃使用索引而进行全表扫描。
- 7）删除长期未使用的索引，会造成不必要的性能损耗。 MySQL5.7 后可以通过查询 sys 库的 schema_unused_indexes 视图来查询哪些索引从未被使用。
- 8）联表查询使用索引提高性能

联表的索引使用要注意如下两点:
1. 确保 ON 和 USING 中的列上有索引。 在创建索引的时候就要考虑关联的顺序。 当表A 和表B 用列c 关联的时候，如果优化器关联的顺序是A、 B，只需要在 B 的 c 字段建立索引即可。
2. 确保任何的 GROUP BY 和 ORDER BY 中的表达式只涉及一个表中的列，这样 MySQL才有可能使用索引来优化。

- 9）在使用 limit offset 查询缓慢时，可以借助索引来提高性能：
```sql
SELECT * FROM test_user a JOIN (select id from test user limit ? , ?) b 
	ON a.id= b . id 
	order by create_time desc
```

- 10）查询条件的字段应使用正确的数据类型，否则会自动做类型转换，导致无法命中索引。例如mobile 列为字符串类型，查询的时候如果没有加''，那么就会进行强制类型转换。

索引可以加快查询速度，但索引也是有代价的：索引文件本身要消耗存储空间，并且在被索引的表上 INSERT/DELETE会变慢；另外，MySQL在运行时也要消耗资源维护索引，因此索引并不是越多越好。 

如下两种情况下不建议建索引。
- 表记录比较少，例如一两千条甚至只有几百条记录的表，没必要建索引
- 索引的选择性较低。 


#### 3、查询缓存
my.cnf：开启查询缓存
```
query_cache_type = 1
query_cache_size = 600000
```

开启查询缓存后在同样的查询条件以及数据情况下，会直接在缓存中返回结果。如果查询中包含任何用户自定义函数、存储函数、用户变量、临时表、MySQL库中的系统表，其查询结果也不会被缓存。

缓存建立之后， MySQL 的查询缓存系统会跟踪查询中涉及的每张表，如果这些表（数据或结构）发生变化，那么和这张表相关的所有缓存数据都将失效。

但是缓存也同时带来了额外的开销，每次查询后都要做一次缓存操作，失效后还要销毁。因此，开启缓存查询要慎重，尤其对于写密集的应用来说更是如此。如果开启，要注意合理控制缓存空间大小， 一般来说其大小设置为几十MB 比较合适。此外，还可以通过 sql_cache / sql_no_cache 来控制某个查询语句是再需要进行缓存：

```
select sql_no_cache count(*) from test_user
```

- [ ] 缓存结构

#### 4、数据同步中的 binlog
Binlog 是用来做 POINT-IN-TIME 的恢复和主从复制，由数据库上层生戚，是 SQL执行的逻辑日志，在事务提交完成后进行一次写入。

Binlog 有如下3种格式:
- 1) Statement 

MySQL 默认 Binlog 格式。 每一条会修改数据的 SQL 都被记录到 bin-log 中，Slave 在复制的时候 SQL 进程会解析成和原来 Master 端执行过的相同的 SQL 后再次执行。

此格式产生的日志量比较少，能够节省 I/O和存储资源，具有较高的可阅读性。但其需要在记录语句信息的同时也记录语句执行时的上下文信息，以保证在 Slave端重放时能够得到和 Master端同样的结果。

此外，并非所有的 UPDATE 语句都能够被复制，尤其是在包含不确定操作的时候，并且 Slave 的数据表必须和 Master 的保持一致。

- 2) Row 

日志中会记录每一行数据被修改的形式，然后在 Slave端再对相同的数据进行修改。 其不需要记录语句执行的上下文信息，但是需要记录每一条记录的改动，因此当受影响的记录很多时，日志量会非常大；由于加密，日志的可阅读性较低。

- 3) Mixed 

Statement 和 Row 的结合。 会根据执行的每一条具体的 SQL 语句来区别对待记录的日志形式


#### 5、事务机制
关系型数据库是需要遵循 ACID 规则的:
- A (Atomic）原子性：即事务要么全部做完，要么全部都不做。 只要其中一个操作失败， 就认为事务失败，需要回滚
- C (Consistency）一致性： 数据库要一直处于一致的状态
- I (Isolation）独立性： 并发的事务之间不会互相影响
- D (Durability）持久性： 一旦事务提交后，它所做的修改将会永久地保存在数据库中

为了达到以上事务特性，数据库定义了几种事务隔离级别

MySQL 的默认事务级别为 Repeatable Read，而 JDBC 的默认事务级别为 Read Committed，因此使用的时候要特别注意。 由于 Read Committed 有不可重复读的问题，因此不能在 Statement 格式的 Binlog 下使用，必须设置为 Mixed 或 Row。

事务隔离的实现基于锁机制和并发调度。 其中并发调度使用的是 MVCC（多版本并发 控制），通过保存修改行的旧版本信息来支持并发一致性读和回滚等特性。


#### 6、锁机制

MySQL 为了解决并发、数据安全的问题，使用了锁机制。可以按照锁的粒度把数据库锁分为表级锁和行级锁。

- 表级锁：锁定粒度大，对当前操作的整张表加锁，加锁快，不会出现死锁。其锁定粒度最大， 触发锁冲突的概率最高，并发度最低。 MyISAM 和 InnoDB 引擎都支持表级锁。

- 行级锁：锁定粒度小，，并发度高，只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。但加锁的开销大，加锁慢，会出现死锁。

InnoDB 支持的行级锁，包括如下这几种：
- Record Lock：对索引项加锁，锁定符合条件的行。其他事务不能修改和删除加锁项
- Gap Lock：对索引项之间的"间隙"加锁，锁定记录的范围（对第一条记录前的间隙或最后一条记录后的间隙加锁），不包含索引项本身。 其他事务不能在锁范围内插入数据，这样就防止了别的事务新增幻影行
- Next-key Lock：锁定索引项本身和索引范围。 即 Record Lock + Gap Lock，可解决幻读问题

##### 表级锁
虽然使用行级锁具有粒度小、并发度高，但是表级锁有时候也是有必要的：
- 事务更新大表中的大部分数据直接使用表级锁效率会更高
- 事务比较复杂，使用行级锁很可能引起死锁导致回滚

表级锁和行级锁可进一步划分为共享锁和排他锁：
- 共享锁（s）：读锁，是读取操作创建的锁。 其他用户可以读取数据，可以再加共享锁，读取到的数据也是同一版本的；但任何事务都不能获取数据上的排他锁，不能对数据进行修改。

获取共享锁的事务只能读取数据而不能修改数据。 可以使用 `SELECT … LOCK IN SHARE MODE`；来强制获取共享锁，否则绝大部分查询操作是不会获取锁的（串行事务级别除外）

- 排他锁（x）：写锁，一个事务对数据加上排他锁后，其他事务不能再对此数据加任何其他类型的锁。获取排他锁的事务既能读取数据也能修改数据。 

InnoDB 对 CUD (insert/update/delete）操作涉及的数据会默认加排他锁。 对于查询语句可以使用 `SELECT … FOR UPDATE` 加排他锁。

InnoDB 中还有如下两个表级锁:
- 意向共享锁（ IS ）： 表示事务准备给数据行加入共享锁，事务在一个数据行加共享锁前必须先取得该表的 IS锁
- 意向排他锁（ IX ）： 表示事务准备给数据行加入排他锁， 事务在一个数据行加排他 锁前必须先取得该表的 IX锁

这里的意向锁是表级锁，表示的是一种意向，仅仅表示事务正在读或写某一行记录，在真正加行级锁时才会判断是否冲突。 意向锁是 InnoDB 自动加的，不需要用户干预。

InnoDB 的行级锁是基于索引实现的，如果查询语句未命中任何索引，那么 InnoDB 会使用表级锁。此外， InnoDB 行级锁是针对索引加的锁，不针对数据记录，因此即使访问不同行的记录，如果使用到了相同的索引键仍然会出现锁冲突。

在通过 `SELECT ... LOCK IN SHARE MODE；或 SELECT ... FOR UPDATE`使用锁的时候，如果表没有定义任何索引，那么 InnoDB 会创建一个隐藏的聚簇索引并使用这个索引来加记录锁。

此外，不同于 MyISAM 总是一次性获得所需的全部锁， InnoDB 的锁是逐步获得的。当两个事务都需要获得对方持有的锁，导致双方都在等待，这时就产生了死锁。 发生死锁后， InnoDB 一般都可以检测到，并使一个事务释放锁回退，另一个则可以获取锁完成事务。可以采取以下的方式避免死锁。
- 通过表级锁来减少死锁产生的概率
- 多个程序尽量约定以相同的顺序访问表（这也是解决并发理论哲学家就餐问题的一种思路）
- 同一个事务尽可能做到一次锁定所需要的所有资源


#### 7、大表优化
- 限定查询范围
- 分库：读写分离
- 缓存：查询缓存，Redis
- 分表：
	- 垂直分区：应用层join
	- 水平分区：策略（时间范围）
- 中间件：客户端分片架构，毕竟减少了一次和中间件的网络I/0


#### 8、高可用支持
MySQL 默认支持主从配置，可以一主一从，也可以一主多从。 \但是这个主从仅仅实现 了读/写分离，并不能解决高可用的问题。

常用的高可用方案如下:
- 1) MHA：此方案可以保障一主多从的高可用，管理节点会定时探测集群中的 Master节点，当 Master 出现故障时，自动将最新数据的 Slave 提升为新的 Master，然后将所有其他的 Slave 重新指向新的Master。 整个故障转移过程对应用程序完全透明。 

- 2) MMM: 双主，只有一个主允许写，另一个主允许读，一个主挂掉，其下面的 Slave 同样挂掉。此方案无法严格保证数据一致性，适用于对数据一致性要求不高的业务场景

在主从模式下，经常遇到的一个问题是 Slave 数据滞后于 Master，写入 Master 后从 Slave 读取不到最新的数据。 可以使用 MySQL5.5 及之后版本引入的半同步复制机制，在 MySQL客户端请求时阻塞，直到数据至少已经同步到一个 Slave或超时，如此可以在一定程度上解决数据一致性的问题。


#### 9、使用提示
- 配置
- ddl: 设计
- dml


#### 10、连接池 druid

监控、 SQL统计

