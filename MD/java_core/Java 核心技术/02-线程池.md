### 第21讲 | Java并发类库提供的线程池有哪几种？ 分别有什么特点？

> 线程是不能够重复启动的，创建或销毁线程存在一定的开销，所以利用线程池技术来提高系统资源利用效率，并简化线程管理

通常都是利用 Executors 提供的通用线程池创建方法，去创建不同配置的线程池，主要区别在于不同的 ExecutorService 类型或者不同的初始参数。

Executors 目前提供了5种不同的线程池创建配置：
- newCachedThreadPool()，用来处理大量短时间工作任务的线程池，有几个鲜明特点：它会试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程；如果线程闲置的时间超过 60 秒，则被终止并移出缓存；长时间闲置时，这种线程池，不会消耗什么资源。其内部使用 SynchronousQueue 作为工作队列。

- newFixedThreadPool(int nThreads)，重用指定数目的线程，背后使用无界工作队列，任何时候最多有 nThreads 个工作线程是活动的。如果任务数量超过了活动队列数目，将在工作队列中等待空闲线程出现；如果有工作线程退出，将会有新的工作线程被创建，以补足指定的数目 nThreads。

- newSingleThreadExecutor()，工作线程数目被限制为 1，操作一个无界的工作队列，所以它保证了所有任务都是被顺序执行，最多有一个任务处于活动状态，且不允许使用者改动线程池实例

- newSingleThreadScheduledExecutor() 和 newScheduledThreadPool(int corePoolSize)，创建的是ScheduledExecutorService，可以进行定时或周期性的工作调度，区别在于单一工作线程还是多个工作线程。

- newWorkStealingPool(int parallelism)，J8 才加入这个创建方法，其内部会构建 `ForkJoinPool`，利用 `Work-Stealing`算法，并行地处理任务，不保证处理顺序。


在大多数应用场景下，使用 Executors 提供的 5 个静态工厂方法就足够了，但是仍然可能需要直接利用 ThreadPoolExecutor 创建，这就要求你对线程构造方式有进一步的了解，你需要明白线程池的设计和结构。

另外，线程池这个定义就是个容易让人误解的术语，因为 ExecutorService 除了通常意义上“池”的功能，还提供了更全面的线程管理、任务提交等方法。


首先，我们来看看 Executor 框架的基本组成，请参考下面的类图：

```
// Executor 是一个基础的接口，其初衷是将任务提交和任务执行细节解耦
void execute(Runnable command);
```

ExecutorService 则更加完善，不仅提供 service 的管理功能，比如 shutdown()等，也提供了更加全面的提交任务机制，如返回`Future` 的 submit()

```
<T> Future<T> submit(Callable<T> task);
```

下面从源码角度，分析线程池的设计与实现，主要围绕 ThreadPoolExecutor 源码。ScheduledThreadPoolExecutor 是 ThreadPoolExecutor 的扩展，主要是增加了调度逻辑。而 ForkJoinPool 则是为 ForkJoinTask 定制的线程池，与通常意义的线程池有所不同。


线程池的几个基本组成部分，一起都体现在线程池的构造函数中，从字面我们就可以大概猜测到其用意：
```
public ThreadPoolExecutor(int corePoolSize,
    int maximumPoolSize,
    long keepAliveTime,
    TimeUnit unit,
    BlockingQueue<Runnable> workQueue,
    ThreadFactory threadFactory,
    RejectedExecutionHandler handler)
```

- `corePoolSize`，核心线程数，。对于不同的线程池，这个值可能会有很大区别，比如 newFixedThreadPool 会将其设置为 nThreads，而对于 newCachedThreadPool 则是为 0。

- `maximumPoolSize`，能够创建的最大线程数。对于 newFixedThreadPool，是 nThreads，而 newCachedThreadPool 则是 Integer.MAX_VALUE。

- keepAliveTime 和 TimeUnit，这两个参数指定了额外的线程能够闲置多久，有些线程池不需要它。

- `workQueue`，工作队列，必须是 BlockingQueue

这里有一个非常有意思的设计，ctl 变量被赋予了双重角色，通过高低位的不同，既表示线程池状态，又表示工作线程数目，这是一个典型的高效优化。试想，实际系统中，虽然我们可以指定线程极限为 Integer.MAX_VALUE，但是因为资源限制，这只是个理论值，所以完全可以将空闲位赋予其他意义。

```
private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
// 真正决定了工作线程数的理论上限 
private static final int COUNT_BITS = Integer.SIZE - 3;
private static final int COUNT_MASK = (1 << COUNT_BITS) - 1;
// 线程池状态，存储在数字的高位
private static final int RUNNING = -1 << COUNT_BITS;

// Packing and unpacking ctl
private static int runStateOf(int c)  { return c & ~COUNT_MASK; }
private static int workerCountOf(int c)  { return c & COUNT_MASK; }
private static int ctlOf(int rs, int wc) { return rs | wc; }
```

- execute()
```
public void execute(Runnable command) {
	int c = ctl.get();
    // 检查工作线程数目，低于 corePoolSize 则添加 Worker
	if (workerCountOf(c) < corePoolSize) {
    	if (addWorker(command, true))
        	return;
    	c = ctl.get();
	}
    // isRunning 就是检查线程池是否被 shutdown
    // 工作队列可能是有界的，offer 是比较友好的入队方式
	if (isRunning(c) && workQueue.offer(command)) {
    	int recheck = ctl.get();
    // 再次进行防御性检查
    	if (! isRunning(recheck) && remove(command))
        	reject(command);
    	else if (workerCountOf(recheck) == 0)
        	addWorker(null, false);
	}
    // 尝试添加一个 worker，如果失败意味着已经饱和或者被 shutdown 了
	else if (!addWorker(command, false))
    	reject(command);
}
```

##### 线程池实践
线程池虽然为提供了非常强大、方便的功能，使用不当同样会导致问题:

- 避免任务堆积。前面 newFixedThreadPool 是创建指定数目的线程，但是其工作队列是无界的，如果工作线程数目太少，导致处理跟不上入队的速度，这就很有可能占用大量系统内存，甚至是出现 OOM。

诊断时，你可以使用 jmap 之类的工具，查看是否有大量的任务对象入队。

- 避免过度扩展线程。通常在处理大量短时任务时，使用缓存的线程池，比如在最新的 HTTP/2 client API 中，默认实现就是如此。我们在创建线程池的时候，并不能准确预计任务压力有多大、数据特征是什么样子（大部分请求是 1K 、100K 还是 1M 以上？），所以很难明确设定一个线程数目。

- 另外，如果线程数目不断增长（可以使用 jstack 等工具检查），也需要警惕另外一种可能性，就是线程泄漏，这种情况往往是因为任务逻辑有问题，导致工作线程迟迟不能被释放。建议你排查下线程栈，很有可能多个线程都是卡在近似的代码处。

- 避免死锁等同步问题

- 尽量避免在使用线程池时操作 ThreadLocal，其原因，工作线程的生命周期通常都会超过任务的生命周期。


##### 线程池大小的选择策略

- 如果我们的任务主要是进行计算，就意味着 CPU 的处理能力是稀缺的资源，如果线程太多，可能导致大量的上下文切换开销。这种情况下，通常建议按照 CPU 核的数目 N 或者 N+1。

- 如果是需要较多等待的任务，例如 I/O 操作比较多，可以参考 Brain Goetz 推荐的计算方法：

```
线程数 = CPU 核数 × 目标 CPU 利用率 ×（1 + 平均等待时间 / 平均工作时间）
```

这些时间并不能精准预计，需要根据采样或者概要分析等方式进行计算，然后在实际中验证和调整。


### 线程池调度器之任务延迟调度实现机制
调度线程执行器 ScheduledThreadPoolExecutor

默认使用了一个特殊的队列作为等待队列，叫做 DelayedWorkQueue，我们可以叫它延迟工作队列

##### DelayedWorkQueue
DWQ 的实现队列是由 RunnableScheduleFuture 数组实现的，我们看看存取相关的接口，发现往队列之中添加元素的实现主要是 offer 接口，看下关键实现：

```java
int i = size;
if (i >= queue.length)
    grow(); // 如果当前元素数量到达了队列的长度，扩充容量
size = i + 1;
if (i == 0) {
    queue[0] = e; // 如果当前队列没有元素，直接放在队头
    setIndex(e, 0);
} else {
    siftUp(i, e);
}
if (queue[0] == e) {
    leader = null;
    available.signal();
}
```

其实 DWQ 队列的实现是基于堆实现的：
```java
/**
 * Sift element added at bottom up to its heap-ordered spot.
 * Call only when holding lock.
 */
private void siftUp(int k, RunnableScheduledFuture key) {
    while (k > 0) {
        int parent = (k - 1) >>> 1;
        RunnableScheduledFuture e = queue[parent];
        if (key.compareTo(e) >= 0)
            break;
        queue[k] = e;
        setIndex(e, k);
        k = parent;
    }
    queue[k] = key;
    setIndex(key, k);
}
```

##### RunableScheduleFuture
下面我们再看看队列元素的实现，上文中我们可以知道，DWQ 这个队列只能存储 RunableScheduleFuture（简称RSF）这个类型的元素，我们看看 RSF 的继承体系：

