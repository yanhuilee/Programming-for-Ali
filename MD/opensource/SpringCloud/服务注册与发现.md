### 将服务注册到 Eureka Server

> Eureka 1.8.X

```
eureka.client.service-url.default-zone
eureka.client.instance.prefer-ip-address
```

关于 Bootstrap 属性
```
# Bootstrap 属性
   启动引导阶段加载的属性
   bootstrap.properties | .yml
   spring.cloud.bootstrap.name=bootstrap

# 常⽤配置
   spring.application.name=应⽤名
   配置中⼼相关
```

#### 使⽤ Spring Cloud LoadBalancer 访问服务

如何获得服务地址
```java
DiscoveryClient#getInstances()
```

Load Balancer Client
```
RestTemplate 与 WebClient
   @LoadBalaced
   实际是通过 ClientHttpRequestInterceptor 实现的
      LoadBalancerInterceptor
      LoadBalancerClient
         RibbonLoadBalancerClient
```

示例：
```java
discoveryClient.getInstances("waiter-service")

restTemplate.getForObject("http://waiter-service/order/{id}", CoffeeOrder.class, id);

// import org.springframework.http.ResponseEntity;
NewOrderRequest orderRequest = NewOrderRequest.builder()
       .customer("Li Lei")
       .items(Arrays.asList("capuccino"))
       .build();
RequestEntity<NewOrderRequest> request = RequestEntity
       .post(UriComponentsBuilder.fromUriString("http://waiter-service/order/").build().toUri())
       .body(orderRequest);
ResponseEntity<CoffeeOrder> response = restTemplate.exchange(request, CoffeeOrder.class);
log.info("Order Request Status Code: {}", response.getStatusCode());
Long id = response.getBody().getId();
```

#### 项目结构

Eureka：分为 Client 和 Server

- Eureka-Server：通过 REST 协议暴露服务，提供应用服务的注册和发现
- Provider：服务提供者，内嵌 Eureka-Client ，通过它向 Eureka-Server 注册自身服务
- Consumer：服务消费者，内嵌 Eureka-Client ，通过它从 Eureka-Server 获取服务列表

#### Eureka-Server 启动
```java
// EurekaClientServerRestIntegrationTest.java
private static void startServer() throws Exception {
   server = new Server(8080);

   // TODO Thread.currentThread().getContextClassLoader() 获取不到路径
   WebAppContext webAppCtx = new WebAppContext(new File("./eureka-server/src/main/webapp").getAbsolutePath(), "/");
   webAppCtx.setDescriptor(new File("./eureka-server/src/main/webapp/WEB-INF/web.xml").getAbsolutePath());
   webAppCtx.setResourceBase(new File("./eureka-server/src/main/resources").getAbsolutePath());
   webAppCtx.setClassLoader(Thread.currentThread().getContextClassLoader());
   server.setHandler(webAppCtx);
   server.start();

   eurekaServiceUrl = "http://localhost:8080/v2";
}
```

自我保护：三次心跳，只读写，不可删除

##### EurekaServerConfig: Eureka-Server 配置接口
- 安全认证：security
- 请求限流： 基于令牌桶算法的 RateLimiter

获取注册信息： 应用注册发现

#### 1、注册： Eureka-Client 向 Eureka-Server 注册应用实例过程
appName, instanceName, ipAddr, port

```
this.scheduler = Executors.newScheduledThreadPool(1,
                new ThreadFactoryBuilder()
                        .setNameFormat("DiscoveryClient-InstanceInfoReplicator-%d")
                        .setDaemon(true)
                        .build());
```

续租 下线 自我保护机制 过期 全量获取 增量获取 覆盖状态
---


### 使⽤ Feign 访问服务
> 声明式 REST Web 服务客户端，https://github.com/OpenFeign/feign

```java
@EnableFeignClients
@FeignClient
feign.client.config.default.connect-timeout=500
feign.client.config.default.read-timeout=500
```

### 使⽤ Zookeeper 作为服务注册中⼼
多副本，有序
```
spring-cloud-starter-zookeeper-discovery
spring.cloud.zookeeper.connect-string=localhost:2181
```

运⾏ Zookeeper 镜像
```
docker run --name zookeeper -p 2181:2181 -d zookeeper:3.5
```

注册中心需要AP，而Zookeeper是CP

@LoadBalanced，RestTemplate增加拦截器，在请求前对请求地址进行替换
LoadBalancerlnterceptor

Ribbon 饥饿加载 eager-load
```
ribbon.eager-load.enabled=true
ribbon.eager-load.clients=需要饥饿加载的服务名
```