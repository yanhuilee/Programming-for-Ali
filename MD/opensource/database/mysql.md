### 大纲目录
- [存储机制](#存储机制)
- [索引](#索引)
- [锁](#锁)
- [主从复制](#主从复制)
- [事务与隔离级别](#事务与隔离级别)

### 存储机制
> 在 InnoDB 引擎中，所有的数据都被**逻辑地**存放在表空间，表空间（tablespace）是存储引擎最高存储单位，下面包括段（segment）、区（extent）、页（page）。

区最小为 1MB，页最少数量为64个。

同一数据库实例所有表空间都有相同的页大小（16k）,可通过 `innodb_page_size` 修改

##### 如何存储表：
InnoDB 会将表的定义（.frm）和数据索引（.idb）等信息分开存储

- .frm 文件：用来描述表的格式，tablename.frm

- .idb 文件：存储了当前表的数据和相关索引数据

##### 如何存储记录：
> 数据在 InnoDB 中是按行存储，每页（16k）可以存放 2-200行记录

行溢出数据：当使用 Compact/Redundant 格式存储极长的 varchar/blob 这类大对象时，并不会直接将所有内容都存放在数据页节点中，而是将数据中的前 768个字节存储在数据页中，后面会通过偏移量指向溢出页。

### 索引

##### 数据结构：B+Tree
将对应页读入内存，并在内存中查找具体的数据行

存储大量的数据（5亿），并不需要太高树的深度（高度3），索引也不是太占内存（4G）。

##### 聚集索引和辅助索引
聚集索引叶节点保存的是整条行记录，表中所有行记录数据老师按聚集索引的顺序存放的。

辅助索引叶节点存放索引中的所有键和对应行记录的指针。

##### 索引设计

### 锁
锁一般分为乐观锁和悲观锁，InnoDB 使用的是悲观锁；
按锁的粒度划分为行锁和表锁

##### 并发控制机制
乐观锁不会存在死锁的问题

当冲突频率和重试成本较高时更推荐使用悲观锁，而需要非常高的响应速度且并发量非常大的时候使用乐观锁就能较好的解决问题；

在选择并发控制机制时，需要综合考虑的四个方面（冲突频率、重试成本、响应速度和并发量）

##### 锁的种类
行级锁：共享锁（Shared Lock）和互斥锁（Exclusive Lock）

共享锁代表了读操作、互斥锁代表了写操作，可以在数据库中并行读，但是只能串行写，这样才能保证不会发生线程竞争，实现线程安全。

##### 锁的粒度
表级锁：意向锁（Intention Lock），也分意向共享锁和互斥锁

> 如果没有意向锁，当已经有人使用行锁对表中的某一行进行修改时，如果另外一个请求要对全表进行修改，那么就需要对所有的行是否被锁定进行扫描，在这种情况下，效率是非常低的；不过，在引入意向锁之后，当有人使用行锁对表中的某一行进行修改之前，会先为表添加意向互斥锁（IX），再为行记录添加互斥锁（X），在这时如果有人尝试对全表进行修改就不需要判断表中的每一行数据是否被加锁了，只需要通过等待意向互斥锁被释放就可以了。

##### 锁的算法
Record Lock、Gap Lock 和 Next-Key Lock

- Record Lock: 索引记录
- Gap Lock： 间隙锁，阻止其他事务向锁定范围中添加新的记录
- Next-Key Lock： 上面两种的结合，锁定当前值和前面的范围

当我们更新一条记录，比如 `SELECT * FROM users WHERE age = 30 FOR UPDATE`，InnoDB 不仅会在范围 (21, 30] 上加 `Next-Key` 锁，还会在这条记录后面的范围 (30, 40] 加`间隙锁`，所以插入 (21, 40] 范围内的记录都会被锁定。

Next-Key 锁的作用其实是为了解决幻读的问题

##### 死锁的发生
InnoDB 中实现的锁是悲观的，那么不同事务之间就可能会互相等待对方释放锁造成死锁，最终导致事务发生错误

两个会话都持有一个锁，并且尝试获取对方的锁时就会发生死锁，不过 MySQL 也能在发生死锁时及时发现问题，并保证其中的一个事务能够正常工作，这对我们来说也是一个好消息。

### 事务与隔离级别

##### ACID
原子性：要么全成功

##### 几种隔离级别
1. RAED UNCOMMITED：使用查询语句不会加锁，可能会读到未提交的行（Dirty Read）；

2. READ COMMITED：只对记录加记录锁，而不会在记录之间加间隙锁，所以允许新的记录插入到被锁定记录的附近，所以再多次使用查询语句时，可能得到不同的结果（Non-Repeatable Read）；

3. REPEATABLE READ：多次读取同一范围的数据会返回第一次查询的快照，不会返回不同的数据行，**可能发生幻读（Phantom Read）**

4. SERIALIZABLE：InnoDB 隐式地将全部的查询语句加上共享锁，解决了幻读的问题；

MySQL 中默认的事务隔离级别就是 REPEATABLE READ，但是它通过 Next-Key 锁也能够在某种程度上解决幻读的问题。

---

**数据预读**的思路是：磁盘读写并不是按需读取，而是按页预读，一次会读一页的数据，每次加载更多的数据，以便未来减少磁盘IO

**局部性原理**：软件设计要尽量遵循“数据读取集中”与“使用到一个数据，大概率会使用其附近的数据”，这样磁盘预读能充分提高磁盘IO

<h3 style="margin-top: 1rem; color: rgb(61, 167, 66); font-size:16px;">Enum</h3>

```
create table size {
  name ENUM('smail', 'medium', 'large')}
```

<h3 style="margin-top: 1rem; color: rgb(61, 167, 66); font-size:16px;">数据类型</h3>

timestamp update current_timestamp

货币：decimal

最大插入ID: last_insert_id

#### 主从复制，每秒30万订单
读写分离

如何同步（单线程？） otter
```
1、Master-binlog（二进制日志）和 Slave-relaylog（中继日志）
2、服务器ID
3、授权信息（密码，ip）


```

---

分页
```sql
select sql_no_cache id from xx limit 8000, 10
```

慢查询参数
```
slowlog-log-slower-than: 预设阀值，即记录超过多少时间的记录，默认10毫秒

slowlog-max-len: 慢查询条数（默认128条），
```